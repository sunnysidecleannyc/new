'use client'
import { useEffect, useState } from 'react'
import { RecurringOptions, generateRecurringDates, getRecurringDisplayName } from '@/components/RecurringOptions'
import AddressAutocomplete from '@/components/AddressAutocomplete'

interface Booking {
  id: string
  start_time: string
  end_time: string
  service_type: string
  price: number
  status: string
  payment_status: string
  payment_method: string | null
  notes: string | null
  client_id: string
  cleaner_id: string
  cleaner_token: string | null
  hourly_rate: number | null
  recurring_type: string | null
  clients: { id: string; name: string; phone: string; address: string } | null
  cleaners: { id: string; name: string } | null
}

interface Client { id: string; name: string; phone: string; email: string; address: string; created_at: string }
interface Cleaner { id: string; name: string }

export default function BookingsPage() {
  const [bookings, setBookings] = useState<Booking[]>([])
  const [filteredBookings, setFilteredBookings] = useState<Booking[]>([])
  const [clients, setClients] = useState<Client[]>([])
  const [cleaners, setCleaners] = useState<Cleaner[]>([])
  const [loading, setLoading] = useState(true)
  const [showModal, setShowModal] = useState(false)
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [showNewClientModal, setShowNewClientModal] = useState(false)
  const [showUpdateChoice, setShowUpdateChoice] = useState(false)
  const [editingBooking, setEditingBooking] = useState<Booking | null>(null)
  const [form, setForm] = useState({ status: '', payment_status: '', payment_method: '', notes: '', cleaner_id: '' })
  const [createForm, setCreateForm] = useState({ 
    client_id: '', cleaner_id: '', start_date: '', start_time: '09:00',
    hours: 2, hourly_rate: 75, service_type: 'Standard Cleaning', notes: '',
    repeat_enabled: false, repeat_type: 'weekly', repeat_end: 'never',
    repeat_end_count: 10, repeat_end_date: '', custom_interval: 3
  })
  const [newClientForm, setNewClientForm] = useState({ name: '', phone: '', email: '', address_line1: '', address_line2: '', city: '', state: '', zip: '' })
  const [saving, setSaving] = useState(false)
  const [copied, setCopied] = useState(false)
  
  // Client search autocomplete
  const [clientSearch, setClientSearch] = useState('')
  const [showClientDropdown, setShowClientDropdown] = useState(false)
  const [filteredClients, setFilteredClients] = useState<Client[]>([])
  
  // Filters
  const [filters, setFilters] = useState({
    status: 'scheduled',
    service_type: '',
    cleaner_id: '',
    client_id: '',
    date_from: '',
    date_to: ''
  })
  const [showFilters, setShowFilters] = useState(false)

  useEffect(() => { loadBookings(); loadClients(); loadCleaners() }, [])
  
  useEffect(() => { applyFilters() }, [bookings, filters])

  // Filter clients when search changes
  useEffect(() => {
    if (clientSearch) {
      const search = clientSearch.toLowerCase()
      const filtered = clients
        .filter(c => 
          c.name.toLowerCase().includes(search) ||
          c.phone.includes(search) ||
          c.email?.toLowerCase().includes(search)
        )
        .sort((a, b) => a.name.localeCompare(b.name))
        .slice(0, 8) // Limit to 8 results
      setFilteredClients(filtered)
    } else {
      setFilteredClients([])
    }
  }, [clientSearch, clients])

  const loadBookings = async () => { 
    const res = await fetch('/api/bookings')
    if (res.ok) {
      const data = await res.json()
      data.sort((a: Booking, b: Booking) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime())
      setBookings(data)
    }
    setLoading(false) 
  }
  const loadClients = async () => { const res = await fetch('/api/clients'); if (res.ok) setClients(await res.json()) }
  const loadCleaners = async () => { const res = await fetch('/api/cleaners'); if (res.ok) setCleaners(await res.json()) }

  const applyFilters = () => {
    let result = [...bookings]
    
    if (filters.status) {
      result = result.filter(b => b.status === filters.status)
    }
    if (filters.service_type) {
      result = result.filter(b => b.service_type === filters.service_type)
    }
    if (filters.cleaner_id) {
      result = result.filter(b => b.cleaner_id === filters.cleaner_id)
    }
    if (filters.client_id) {
      result = result.filter(b => b.client_id === filters.client_id)
    }
    if (filters.date_from) {
      result = result.filter(b => new Date(b.start_time) >= new Date(filters.date_from))
    }
    if (filters.date_to) {
      result = result.filter(b => new Date(b.start_time) <= new Date(filters.date_to + 'T23:59:59'))
    }
    
    setFilteredBookings(result)
  }

  const clearFilters = () => {
    setFilters({ status: 'scheduled', service_type: '', cleaner_id: '', client_id: '', date_from: '', date_to: '' })
  }

  const openEdit = (booking: Booking) => {
    setEditingBooking(booking)
    setForm({ status: booking.status, payment_status: booking.payment_status, payment_method: booking.payment_method || '', notes: booking.notes || '', cleaner_id: booking.cleaner_id || '' })
    setShowModal(true)
    setCopied(false)
  }

  const openCreate = () => {
    const tomorrow = new Date()
    tomorrow.setDate(tomorrow.getDate() + 1)
    const endDate = new Date()
    endDate.setMonth(endDate.getMonth() + 3)
    setCreateForm({ 
      client_id: '', cleaner_id: '', start_date: tomorrow.toISOString().split('T')[0],
      start_time: '09:00', hours: 2, hourly_rate: 75, service_type: 'Standard Cleaning', notes: '',
      repeat_enabled: false, repeat_type: 'weekly', repeat_end: 'never',
      repeat_end_count: 10, repeat_end_date: endDate.toISOString().split('T')[0], custom_interval: 3
    })
    setClientSearch('')
    setShowClientDropdown(false)
    setShowCreateModal(true)
  }

  const handleClientSelect = (client: Client) => {
    setCreateForm({ ...createForm, client_id: client.id })
    setClientSearch(client.name + ' - ' + client.phone)
    setShowClientDropdown(false)
  }

  const handleClientSearchChange = (value: string) => {
    setClientSearch(value)
    setCreateForm({ ...createForm, client_id: '' })
    setShowClientDropdown(true)
  }

  const handleNewClientClick = () => {
    setNewClientForm({ name: '', phone: '', email: '', address_line1: '', address_line2: '', city: '', state: '', zip: '' })
    setShowNewClientModal(true)
    setShowClientDropdown(false)
  }

  const handleNewClientAddressSelect = (addr: { address_line1: string, city: string, state: string, zip: string }) => {
    setNewClientForm({ ...newClientForm, ...addr })
  }

  const handleNewClientSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setSaving(true)
    const fullAddress = [newClientForm.address_line1, newClientForm.address_line2, newClientForm.city, newClientForm.state, newClientForm.zip].filter(Boolean).join(', ')
    const res = await fetch('/api/clients', { 
      method: 'POST', 
      headers: { 'Content-Type': 'application/json' }, 
      body: JSON.stringify({ ...newClientForm, address: fullAddress }) 
    })
    if (res.ok) {
      const newClient = await res.json()
      await loadClients()
      setCreateForm({ ...createForm, client_id: newClient.id })
      setClientSearch(newClient.name + ' - ' + newClient.phone)
      setShowNewClientModal(false)
      setNewClientForm({ name: '', phone: '', email: '', address_line1: '', address_line2: '', city: '', state: '', zip: '' })
    }
    setSaving(false)
  }

  const isExistingClient = (clientId: string) => {
    const client = clients.find(c => c.id === clientId)
    if (!client) return false
    return new Date(client.created_at) < new Date(Date.now() - 24 * 60 * 60 * 1000)
  }

  const calculatePrice = () => {
    const basePrice = createForm.hours * createForm.hourly_rate * 100
    if (createForm.hourly_rate === 75 && createForm.client_id && isExistingClient(createForm.client_id)) {
      return Math.round(basePrice * 0.9)
    }
    return basePrice
  }

  const getEstimatedHoursRange = (hours: number) => {
    const ranges: Record<number, string> = { 1: '1-2', 2: '2-3', 3: '3-4', 4: '4-6', 5: '5-7', 6: '6-8', 7: '7-9' }
    return ranges[hours] || hours + '-' + (hours + 2)
  }

  const recurringDates = generateRecurringDates(
    createForm.start_date, createForm.repeat_enabled, createForm.repeat_type,
    createForm.repeat_end, createForm.repeat_end_count, createForm.repeat_end_date, createForm.custom_interval
  )

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    // Check if this is a recurring booking and changes were made
    if (editingBooking?.recurring_type && (form.cleaner_id !== editingBooking.cleaner_id || form.notes !== (editingBooking.notes || ''))) {
      setShowUpdateChoice(true)
      return
    }
    await saveBooking('single')
  }

  const saveBooking = async (scope: 'single' | 'all') => {
    setSaving(true)
    setShowUpdateChoice(false)
    
    if (scope === 'all' && editingBooking?.recurring_type) {
      // Update all future bookings with same recurring_type, client, and scheduled status
      const futureBookings = bookings.filter(b => 
        b.client_id === editingBooking.client_id &&
        b.recurring_type === editingBooking.recurring_type &&
        b.status === 'scheduled' &&
        new Date(b.start_time) >= new Date(editingBooking.start_time)
      )
      
      for (let i = 0; i < futureBookings.length; i++) { const booking = futureBookings[i];
        await fetch('/api/bookings/' + booking.id, { 
          method: 'PUT', 
          headers: { 'Content-Type': 'application/json' }, 
          body: JSON.stringify(form) 
        })
      }
    } else {
      await fetch('/api/bookings/' + editingBooking?.id, { 
        method: 'PUT', 
        headers: { 'Content-Type': 'application/json' }, 
        body: JSON.stringify(form) 
      })
    }
    
    setShowModal(false)
    setEditingBooking(null)
    loadBookings()
    setSaving(false)
  }

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault(); setSaving(true)
    const recurringType = createForm.repeat_enabled ? getRecurringDisplayName(createForm.repeat_type, createForm.start_date) : null
    
    for (let i = 0; i < recurringDates.length; i++) {
      const date = recurringDates[i]
      const startDateTime = new Date(date + 'T' + createForm.start_time)
      const endDateTime = new Date(startDateTime.getTime() + createForm.hours * 60 * 60 * 1000)
      await fetch('/api/bookings', { 
        method: 'POST', headers: { 'Content-Type': 'application/json' }, 
        body: JSON.stringify({
          client_id: createForm.client_id, cleaner_id: createForm.cleaner_id,
          start_time: startDateTime.toISOString(), end_time: endDateTime.toISOString(),
          service_type: createForm.service_type, price: calculatePrice(),
          hourly_rate: createForm.hourly_rate, recurring_type: recurringType, notes: createForm.notes || null,
          skip_email: i > 0
        }) 
      })
    }
    setShowCreateModal(false); loadBookings(); setSaving(false)
  }

  const handleCancel = async (scope: 'single' | 'all') => {
    if (!editingBooking) return
    setSaving(true)
    
    if (scope === 'all' && editingBooking.recurring_type) {
      const futureBookings = bookings.filter(b => 
        b.client_id === editingBooking.client_id &&
        b.recurring_type === editingBooking.recurring_type &&
        b.status === 'scheduled' &&
        new Date(b.start_time) >= new Date(editingBooking.start_time)
      )
      
      for (let i = 0; i < futureBookings.length; i++) { const booking = futureBookings[i];
        await fetch('/api/bookings/' + booking.id + (i > 0 ? '?skip_email=true' : ''), { method: 'DELETE' })
      }
    } else {
      await fetch('/api/bookings/' + editingBooking.id, { method: 'DELETE' })
    }
    
    setShowModal(false)
    setEditingBooking(null)
    loadBookings()
    setSaving(false)
  }

  const copyTeamLink = () => {
    if (editingBooking?.cleaner_token) {
      navigator.clipboard.writeText(window.location.origin + '/team/' + editingBooking.cleaner_token)
      setCopied(true); setTimeout(() => setCopied(false), 2000)
    }
  }

  const formatDate = (dateStr: string) => new Date(dateStr).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })

  const serviceTypes = ['Standard Cleaning', 'Deep Cleaning', 'Move In/Out', 'Post Construction']

  const activeFilterCount = [filters.status !== 'scheduled', filters.service_type, filters.cleaner_id, filters.client_id, filters.date_from, filters.date_to].filter(Boolean).length

  return (
    <div className="min-h-screen bg-white">
      <header className="border-b border-gray-200 px-6 py-4">
        <div className="flex justify-between items-center">
          <h1 className="text-xl font-semibold text-black">The NYC Maid</h1>
          <nav className="flex gap-8">
            <a href="/dashboard" className="text-gray-500 hover:text-black">Dashboard</a>
            <a href="/dashboard/calendar" className="text-gray-500 hover:text-black">Calendar</a>
            <a href="/dashboard/bookings" className="text-black font-medium border-b-2 border-black pb-1">Bookings</a>
            <a href="/dashboard/clients" className="text-gray-500 hover:text-black">Clients</a>
            <a href="/dashboard/cleaners" className="text-gray-500 hover:text-black">Team</a>
            <a href="/dashboard/websites" className="text-gray-500 hover:text-black">Websites</a>
          </nav>
        </div>
      </header>
      <main className="p-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold text-black">Bookings</h2>
          <div className="flex gap-3">
            <button onClick={() => setShowFilters(!showFilters)} className={'px-4 py-2 border rounded-lg font-medium ' + (showFilters || activeFilterCount > 0 ? 'border-black bg-black text-white' : 'border-gray-300 text-black')}>
              Filters {activeFilterCount > 0 && `(${activeFilterCount})`}
            </button>
            <button onClick={openCreate} className="bg-black text-white px-4 py-2 rounded-lg font-medium hover:bg-gray-800">Create</button>
          </div>
        </div>
        
        {/* Filters Panel */}
        {showFilters && (
          <div className="bg-gray-50 rounded-lg p-4 mb-4 space-y-4">
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Status</label>
                <select value={filters.status} onChange={(e) => setFilters({ ...filters, status: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm">
                  <option value="">All</option>
                  <option value="scheduled">Scheduled</option>
                  <option value="completed">Completed</option>
                  <option value="cancelled">Cancelled</option>
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Service</label>
                <select value={filters.service_type} onChange={(e) => setFilters({ ...filters, service_type: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm">
                  <option value="">All</option>
                  {serviceTypes.map(s => <option key={s} value={s}>{s}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Cleaner</label>
                <select value={filters.cleaner_id} onChange={(e) => setFilters({ ...filters, cleaner_id: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm">
                  <option value="">All</option>
                  {cleaners.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">Client</label>
                <select value={filters.client_id} onChange={(e) => setFilters({ ...filters, client_id: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm">
                  <option value="">All</option>
                  {[...clients].sort((a,b) => a.name.localeCompare(b.name)).map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">From</label>
                <input type="date" value={filters.date_from} onChange={(e) => setFilters({ ...filters, date_from: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm" />
              </div>
              <div>
                <label className="block text-xs font-medium text-gray-600 mb-1">To</label>
                <input type="date" value={filters.date_to} onChange={(e) => setFilters({ ...filters, date_to: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm" />
              </div>
            </div>
            <div className="flex justify-between items-center">
              <p className="text-sm text-gray-600">{filteredBookings.length} booking{filteredBookings.length !== 1 ? 's' : ''}</p>
              <button onClick={clearFilters} className="text-sm text-gray-500 hover:text-black">Clear Filters</button>
            </div>
          </div>
        )}

        <div className="border border-gray-200 rounded-lg overflow-hidden">
          {loading ? <p className="p-6 text-gray-500">Loading...</p> : filteredBookings.length === 0 ? <p className="p-6 text-gray-500">No bookings found.</p> : (
            <table className="w-full">
              <thead className="bg-gray-50 border-b border-gray-200">
                <tr>
                  <th className="text-left p-4 font-medium text-black text-sm">Date/Time</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Client</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Staff</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Service</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Rate</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Est.</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Recurring</th>
                  <th className="text-left p-4 font-medium text-black text-sm">Status</th>
                  <th className="text-left p-4 font-medium text-black text-sm"></th>
                </tr>
              </thead>
              <tbody>
                {filteredBookings.map((b) => (
                  <tr key={b.id} className="border-b border-gray-100 hover:bg-gray-50 cursor-pointer" onClick={() => openEdit(b)}>
                    <td className="p-4 text-black">{formatDate(b.start_time)}</td>
                    <td className="p-4 text-black font-medium">{b.clients?.name || '-'}</td>
                    <td className="p-4 text-gray-600">{b.cleaners?.name || '-'}</td>
                    <td className="p-4 text-gray-600">{b.service_type}</td>
                    <td className="p-4 text-gray-600">{b.hourly_rate ? '$' + b.hourly_rate + '/hr' : '-'}</td>
                    <td className="p-4 text-black">~${(b.price / 100).toFixed(0)}</td>
                    <td className="p-4">{b.recurring_type ? <span className="px-2 py-1 bg-purple-100 text-purple-700 rounded-full text-xs">{b.recurring_type}</span> : '-'}</td>
                    <td className="p-4"><span className={'px-2 py-1 rounded-full text-xs font-medium ' + (b.status === 'completed' ? 'bg-green-100 text-green-700' : b.status === 'cancelled' ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700')}>{b.status}</span></td>
                    <td className="p-4 text-gray-400">Edit</td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </main>

      {showModal && editingBooking && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md max-h-[90vh] overflow-y-auto">
            <h3 className="text-lg font-semibold text-black mb-2">Edit Booking</h3>
            <p className="text-gray-500 text-sm mb-4">{editingBooking.clients?.name} - {formatDate(editingBooking.start_time)}</p>
            {editingBooking.recurring_type && (
              <p className="text-purple-600 text-sm mb-4 bg-purple-50 px-3 py-2 rounded-lg">ðŸ”„ Recurring: {editingBooking.recurring_type}</p>
            )}
            {editingBooking.cleaner_token && (
              <button type="button" onClick={copyTeamLink} className="w-full mb-4 py-2 px-4 bg-blue-50 text-blue-700 border border-blue-200 rounded-lg font-medium hover:bg-blue-100">
                {copied ? 'Copied!' : 'Copy Team Link'}
              </button>
            )}
            <form onSubmit={handleSubmit}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Cleaner</label>
                  <select value={form.cleaner_id} onChange={(e) => setForm({ ...form, cleaner_id: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    <option value="">Select...</option>
                    {cleaners.map((c) => <option key={c.id} value={c.id}>{c.name}</option>)}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Status</label>
                  <select value={form.status} onChange={(e) => setForm({ ...form, status: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    <option value="scheduled">Scheduled</option>
                    <option value="completed">Completed</option>
                    <option value="cancelled">Cancelled</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Payment</label>
                  <select value={form.payment_status} onChange={(e) => setForm({ ...form, payment_status: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    <option value="pending">Pending</option>
                    <option value="paid">Paid</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Method</label>
                  <select value={form.payment_method} onChange={(e) => setForm({ ...form, payment_method: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    <option value="">-</option>
                    <option value="zelle">Zelle</option>
                    <option value="apple_pay">Apple Pay</option>
                    <option value="cash">Cash</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Notes</label>
                  <textarea value={form.notes} onChange={(e) => setForm({ ...form, notes: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black" rows={2} />
                </div>
              </div>
              <div className="flex gap-3 mt-6">
                {editingBooking.recurring_type ? (
                  <div className="relative group">
                    <button type="button" className="px-4 py-2 text-red-600 hover:bg-red-50 rounded-lg">Cancel â–¾</button>
                    <div className="absolute left-0 bottom-full mb-1 hidden group-hover:block bg-white border rounded-lg shadow-lg py-1 min-w-[180px]">
                      <button type="button" onClick={() => handleCancel('single')} className="w-full px-4 py-2 text-left text-red-600 hover:bg-red-50 text-sm">This booking only</button>
                      <button type="button" onClick={() => handleCancel('all')} className="w-full px-4 py-2 text-left text-red-600 hover:bg-red-50 text-sm">All future bookings</button>
                    </div>
                  </div>
                ) : (
                  <button type="button" onClick={() => handleCancel('single')} className="px-4 py-2 text-red-600 hover:bg-red-50 rounded-lg">Cancel Booking</button>
                )}
                <button type="button" onClick={() => { setShowModal(false); setEditingBooking(null) }} className="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-black">Close</button>
                <button type="submit" disabled={saving} className="flex-1 px-4 py-2 bg-black text-white rounded-lg">{saving ? '...' : 'Save'}</button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Update Choice Modal for Recurring */}
      {showUpdateChoice && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
          <div className="bg-white rounded-lg p-6 w-full max-w-sm">
            <h3 className="text-lg font-semibold text-black mb-4">Update Recurring Booking</h3>
            <p className="text-gray-600 mb-6">Apply changes to:</p>
            <div className="space-y-3">
              <button onClick={() => saveBooking('single')} className="w-full py-3 px-4 border border-gray-300 rounded-lg text-black hover:bg-gray-50 text-left">
                <p className="font-medium">This booking only</p>
                <p className="text-sm text-gray-500">Only update this appointment</p>
              </button>
              <button onClick={() => saveBooking('all')} className="w-full py-3 px-4 border border-gray-300 rounded-lg text-black hover:bg-gray-50 text-left">
                <p className="font-medium">All future bookings</p>
                <p className="text-sm text-gray-500">Update this and all upcoming appointments</p>
              </button>
            </div>
            <button onClick={() => setShowUpdateChoice(false)} className="w-full mt-4 py-2 text-gray-500 hover:text-black">Cancel</button>
          </div>
        </div>
      )}

      {showCreateModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-lg max-h-[90vh] overflow-y-auto">
            <h3 className="text-lg font-semibold text-black mb-4">Create Booking</h3>
            <form onSubmit={handleCreate}>
              <div className="space-y-4">
                {/* Client Autocomplete Search */}
                <div className="relative">
                  <label className="block text-sm font-medium text-black mb-1">Client *</label>
                  <input
                    type="text"
                    required={!createForm.client_id}
                    value={clientSearch}
                    onChange={(e) => handleClientSearchChange(e.target.value)}
                    onFocus={() => setShowClientDropdown(true)}
                    placeholder="Search by name or phone..."
                    className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black"
                  />
                  
                  {showClientDropdown && (
                    <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-lg shadow-lg max-h-64 overflow-y-auto">
                      <button
                        type="button"
                        onClick={handleNewClientClick}
                        className="w-full px-3 py-2 text-left hover:bg-gray-50 border-b border-gray-200 font-medium text-blue-600"
                      >
                        + New Client
                      </button>
                      {filteredClients.length > 0 ? (
                        filteredClients.map((client) => (
                          <button
                            key={client.id}
                            type="button"
                            onClick={() => handleClientSelect(client)}
                            className="w-full px-3 py-2 text-left hover:bg-gray-50 border-b border-gray-100 last:border-b-0"
                          >
                            <div className="font-medium text-black">{client.name}</div>
                            <div className="text-sm text-gray-500">{client.phone}</div>
                          </button>
                        ))
                      ) : clientSearch ? (
                        <div className="px-3 py-2 text-gray-500 text-sm">No clients found</div>
                      ) : (
                        <div className="px-3 py-2 text-gray-500 text-sm">Start typing to search...</div>
                      )}
                    </div>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium text-black mb-1">Cleaner *</label>
                  <select required value={createForm.cleaner_id} onChange={(e) => setCreateForm({ ...createForm, cleaner_id: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    <option value="">Select...</option>
                    {cleaners.map((c) => <option key={c.id} value={c.id}>{c.name}</option>)}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Service</label>
                  <select value={createForm.service_type} onChange={(e) => setCreateForm({ ...createForm, service_type: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                    {serviceTypes.map(s => <option key={s}>{s}</option>)}
                  </select>
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">Hours</label>
                    <select value={createForm.hours} onChange={(e) => setCreateForm({ ...createForm, hours: parseInt(e.target.value) })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                      {[1,2,3,4,5,6,7,8].map(h => <option key={h} value={h}>{h}hr</option>)}
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">Rate</label>
                    <select value={createForm.hourly_rate} onChange={(e) => setCreateForm({ ...createForm, hourly_rate: parseInt(e.target.value) })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black">
                      <option value={49}>$49/hr</option>
                      <option value={75}>$75/hr</option>
                    </select>
                  </div>
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">Date *</label>
                    <input type="date" required value={createForm.start_date} onChange={(e) => setCreateForm({ ...createForm, start_date: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black" />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">Time *</label>
                    <input type="time" required value={createForm.start_time} onChange={(e) => setCreateForm({ ...createForm, start_time: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black" />
                  </div>
                </div>

                <RecurringOptions
                  startDate={createForm.start_date}
                  enabled={createForm.repeat_enabled}
                  onEnabledChange={(v) => setCreateForm({ ...createForm, repeat_enabled: v })}
                  repeatType={createForm.repeat_type}
                  onRepeatTypeChange={(v) => setCreateForm({ ...createForm, repeat_type: v })}
                  repeatEnd={createForm.repeat_end}
                  onRepeatEndChange={(v) => setCreateForm({ ...createForm, repeat_end: v })}
                  repeatEndCount={createForm.repeat_end_count}
                  onRepeatEndCountChange={(v) => setCreateForm({ ...createForm, repeat_end_count: v })}
                  repeatEndDate={createForm.repeat_end_date}
                  onRepeatEndDateChange={(v) => setCreateForm({ ...createForm, repeat_end_date: v })}
                  customInterval={createForm.custom_interval}
                  onCustomIntervalChange={(v) => setCreateForm({ ...createForm, custom_interval: v })}
                  previewDates={recurringDates}
                />

                <div className="bg-gray-50 rounded-lg p-4">
                  <p className="text-xs text-gray-500 mb-2">ESTIMATE</p>
                  <div className="flex justify-between">
                    <span>~{getEstimatedHoursRange(createForm.hours)}hrs x ${createForm.hourly_rate}/hr</span>
                    <span className="font-semibold">~${((calculatePrice() / 100) * recurringDates.length).toFixed(0)}</span>
                  </div>
                  {recurringDates.length > 1 && <p className="text-xs text-gray-500 mt-1">{recurringDates.length} bookings</p>}
                </div>

                <div>
                  <label className="block text-sm font-medium text-black mb-1">Notes</label>
                  <textarea value={createForm.notes} onChange={(e) => setCreateForm({ ...createForm, notes: e.target.value })} className="w-full px-3 py-2 border border-gray-300 rounded-lg text-black" rows={2} placeholder="Access codes..." />
                </div>
              </div>
              <div className="flex gap-3 mt-6">
                <button type="button" onClick={() => { setShowCreateModal(false); setShowClientDropdown(false) }} className="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-black">Cancel</button>
                <button type="submit" disabled={saving || !createForm.client_id} className="flex-1 px-4 py-2 bg-black text-white rounded-lg disabled:bg-gray-300">
                  {saving ? 'Creating...' : recurringDates.length > 1 ? 'Create ' + recurringDates.length + ' Bookings' : 'Create'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {showNewClientModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60]">
          <div className="bg-white rounded-lg p-6 w-full max-w-md max-h-[90vh] overflow-y-auto">
            <h3 className="text-lg font-semibold text-black mb-4">New Client</h3>
            <form onSubmit={handleNewClientSubmit}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Name *</label>
                  <input type="text" required value={newClientForm.name} onChange={(e) => setNewClientForm({ ...newClientForm, name: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Phone *</label>
                  <input type="tel" required value={newClientForm.phone} onChange={(e) => setNewClientForm({ ...newClientForm, phone: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black" />
                </div>
                <div>
                  <label className="block text-sm font-medium text-black mb-1">Email</label>
                  <input type="email" value={newClientForm.email} onChange={(e) => setNewClientForm({ ...newClientForm, email: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black" />
                </div>
                <AddressAutocomplete 
                  onSelect={handleNewClientAddressSelect}
                  initialValue={newClientForm.address_line1}
                />
                <div className="grid grid-cols-3 gap-2">
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">City</label>
                    <input type="text" value={newClientForm.city} onChange={(e) => setNewClientForm({ ...newClientForm, city: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm" />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">State</label>
                    <input type="text" value={newClientForm.state} onChange={(e) => setNewClientForm({ ...newClientForm, state: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm" maxLength={2} />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-black mb-1">Zip</label>
                    <input type="text" value={newClientForm.zip} onChange={(e) => setNewClientForm({ ...newClientForm, zip: e.target.value })} className="w-full px-3 py-2 border rounded-lg text-black text-sm" maxLength={10} />
                  </div>
                </div>
              </div>
              <div className="flex gap-3 mt-6">
                <button type="button" onClick={() => setShowNewClientModal(false)} className="flex-1 px-4 py-2 border border-gray-300 rounded-lg text-black">Cancel</button>
                <button type="submit" disabled={saving} className="flex-1 px-4 py-2 bg-black text-white rounded-lg">{saving ? '...' : 'Create'}</button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}
